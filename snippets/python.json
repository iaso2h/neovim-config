{
    "#!": {
        "prefix": ["#!"],
        "body": [
            "#!/usr/bin/env python",
            "$0"
        ],
    "description": "#!/usr/bin/env python"
    },
    "main": {
        "prefix": ["ifmain"],
        "body": [
            "if __name__ == `!p snip.rv = get_quoting_style(snip)`__main__`!p snip.rv = get_quoting_style(snip)`:",
            "\t${1:${VISUAL:main()}}"
        ],
    "description": "ifmain"
    },
    "with code block": {
        "prefix": ["with"],
        "body": [
            "with ${1:expr}`!p snip.rv = \" as \" if t[2] else \"\"`${2:var}:",
            "\t${3:${VISUAL:pass}}",
            "$0"
        ],
    "description": "with"
    },
    "for loop": {
        "prefix": ["for"],
        "body": [
            "for ${1:item} in ${2:iterable}:",
            "\t${3:${VISUAL:pass}}"
        ],
    "description": "for loop"
    },
    "class with docstrings": {
        "prefix": ["class"],
        "body": [
        "class ${1:MyClass}(${2:object}):",
        "",
        "\t`!p snip.rv = triple_quotes(snip)`${3:Docstring for $1. }`!p snip.rv = triple_quotes(snip)`,",
        "",
        "\tdef __init__(self$4):",
		"\t\t`!p snip.rv = triple_quotes(snip)`${5:TODO: to be defined.}`!p",
        "snip.rv = \"\t",
        "snip >> 2",
        "",
        "args = get_args(t[4])",
        "",
        "write_docstring_args(args, snip)",
        "if args:",
        "\tsnip.rv += '\n' + snip.mkline('', indent='')",
        "\tsnip += '{0}'.format(triple_quotes(snip))",
        "",
        "write_init_body(args, t[2], snip)",
        "`",
        "\t\t$0"
        ],
    "description": "class with docstrings"
    },
    "class with slots and docstrings": {
        "prefix": ["slotclass"],
        "body": [
"class ${1:MyClass}(${2:object}):",
"",
	"\t`!p snip.rv = triple_quotes(snip)`${3:Docstring for $1. }`!p snip.rv = triple_quotes(snip)`",
"`!p",
"snip >> 1",
"args = get_args(t[4])",
"write_slots_args(args, snip)",
"`",
"",
	"\tdef __init__(self$4):",
		"\t\t`!p snip.rv = triple_quotes(snip)`${5:TODO: to be defined.}`!p",
"snip.rv = \"\"",
"snip >> 2",
"",
"args = get_args(t[4])",
"",
"write_docstring_args(args, snip)",
"if args:",
	"\tsnip.rv += '\n' + snip.mkline('', indent='')",
	"\tsnip += triple_quotes(snip)",
"",
"write_init_body(args, t[2], snip)",
"`",
		"\t\t$0",
"endsnippet",
"",
"",
"{",
    "\t\"contain\": {",
        "\t\t\"prefix\": [\"contain\"],",
        "\t\t\"body\": [",
"",
        "\t\t],",
    "\t\"description\": \"methods for emulating a container type\"",
    "\t}",
"}",
"def __len__(self):",
	"\t${1:pass}",
"",
"def __getitem__(self, key):",
	"\t${2:pass}",
"",
"def __setitem__(self, key, value):",
	"\t${3:pass}",
"",
"def __delitem__(self, key):",
	"\t${4:pass}",
"",
"def __iter__(self):",
	"\t${5:pass}",
"",
"def __reversed__(self):",
	"\t${6:pass}",
"",
"def __contains__(self, item):",
	"\t${7:pass}",
"endsnippet",
"",
"",
"{",
    "\t\"context\": {",
        "\t\t\"prefix\": [\"context\"],",
        "\t\t\"body\": [",
"",
        "\t\t],",
    "\t\"description\": \"context manager methods\"",
    "}",
"}",
"def __enter__(self):",
	"\t${1:pass}",
"",
"def __exit__(self, exc_type, exc_value, traceback):",
	"\t${2:pass}",
"endsnippet",
"",
"",
"{",
    "\t\"attr\": {",
        "\t\t\"prefix\": [\"attr\"],",
        "\t\t\"body\": [",
"",
        "\t\t],",
    "\t\"description\": \"methods for customizing attribute access\"",
    "\t}",
"}",
"def __getattr__(self, name):",
	"\t${1:pass}",
"",
"def __setattr__(self, name, value):",
	"\t${2:pass}",
"",
"def __delattr__(self, name):",
	"\t${3:pass}",
"endsnippet",
"",
"",
"{",
    "\t\"desc\": {",
        "\t\t\"prefix\": [\"desc\"],",
        "\t\t\"body\": [",
"",
        "\t\t],",
    "\t\"description\": \"methods implementing descriptors\"",
    "\t}",
"}",
"def __get__(self, instance, owner):",
	"\t${1:pass}",
"",
"def __set__(self, instance, value):",
	"\t${2:pass}",
"",
"def __delete__(self, instance):",
	"\t${3:pass}",
"endsnippet",
"",
"",
"{",
    "\t\"cmp\": {",
        "\t\t\"prefix\": [\"cmp\"],",
        "\t\t\"body\": [",
"",
        "\t\t],",
    "\t\"description\": \"",
    "}",
"}",
"def __eq__(self, other):",
	"\t${1:pass}",
"",
"def __ne__(self, other):",
	"\t${2:pass}",
"",
"def __lt__(self, other):",
	"\t${3:pass}",
"",
"def __le__(self, other):",
	"\t${4:pass}",
"",
"def __gt__(self, other):",
	"\t${5:pass}",
"",
"def __ge__(self, other):",
	"\t${6:pass}",
"",
"def __cmp__(self, other):",
	"\t${7:pass}"
        ],
    "description": "class with slots and docstrings"
    },
    "repr": {
        "prefix": ["repr"],
        "body": [
            "def __repr__(self):",
                "\t${1:pass},",
"",
            "def __str__(self):",
                "\t${2:pass}",
"",
            "def __unicode__(self):",
                "\t${3:pass}"
        ],
    "description": ""
    },
    "numeric": {
        "prefix": ["numeric"],
        "body": [
            "def __add__(self, other):",
                "\t${1:pass}",
            "",
            "def __sub__(self, other):",
                "\t${2:pass}",
            "",
            "def __mul__(self, other):",
                "\t${3:pass}",
            "",
            "def __div__(self, other):",
                "\t${4:pass}",
            "",
            "def __truediv__(self, other):",
                "\t${5:pass}",
            "",
            "def __floordiv__(self, other):",
                "\t${6:pass}",
            "",
            "",
            "def __mod__(self, other):",
                "\t${7:pass}",
            "",
            "def __divmod__(self, other):",
                "\t${8:pass}",
            "",
            "def __pow__(self, other):",
                "\t${9:pass}",
            "",
            "",
            "def __lshift__(self, other):",
                "\t${10:pass}",
            "",
            "def __rshift__(self, other):",
                "\t${11:pass}",
            "",
            "def __and__(self, other):",
                "\t${12:pass}",
            "",
            "def __xor__(self, other):",
                "\t${13:pass}",
            "",
            "def __or__(self, other):",
                "\t${14:pass}",
            "",
            "",
            "def __neg__(self):",
                "\t${15:pass}",
            "",
            "def __pos__(self):",
                "\t${16:pass}",
            "",
            "def __abs__(self):",
                "\t${17:pass}",
            "",
            "def __invert__(self):",
                "\t${18:pass}",
            "",
            "",
            "def __complex__(self):",
                "\t${19:pass}",
            "",
            "def __int__(self):",
                "\t${20:pass}",
            "",
            "def __long__(self):",
                "\t${21:pass}",
            "",
            "def __float__(self):",
                "\t${22:pass}",
            "",
            "",
            "def __oct__(self):",
                "\t${22:pass}",
            "",
            "def __hex__(self):",
                "\t${23:pass}",
            "",
            "",
            "def __index__(self):",
                "\t${24:pass}",
            "",
            "def __coerce__(self, other):",
                "\t${25:pass}"
            ],
    "description": "methods for emulating a numeric type"
    },
    "deff": {
        "prefix": ["deff"],
        "body": [
        "def ${1:fname}(`!p snip.rv = \"self, \" if snip.indent else \"\"`$2):",
            "\t$0"
        ],
    "description": "function or class method"
    },
    "def": {
        "prefix": ["def"],
        "body": [
    "def ${1:function}(`!p",
    "if snip.indent:",
        "\tsnip.rv = 'self' + (\", \" if len(t[2]) else \"\")`${2:arg1}):",
        "\t`!p snip.rv = triple_quotes(snip)`${4:TODO: Docstring for $1.}`!p",
    "write_function_docstring(t, snip) `",
        "\t${5:${VISUAL:pass}}",
    "endsnippet"
        ],
    "description": "function with docstrings"
    },
    "defc": {
        "prefix": ["defc"],
        "body": [
"@classmethod",
"def ${1:function}(`!p",
"if snip.indent:",
	"\tsnip.rv = 'cls' + (\", \" if len(t[2]) else \"\")`${2:arg1}):",
	"\t`!p snip.rv = triple_quotes(snip)`${4:TODO: Docstring for $1.}`!p",
"write_function_docstring(t, snip) `",
	"\t${5:${VISUAL:pass}}",
"endsnippet"
        ],
    "description": "class method with docstrings"
    },
    "defs": {
        "prefix": ["defs"],
        "body": [
            "@staticmethod",
            "def ${1:function}(${2:arg1}):",
                "\t`!p snip.rv = triple_quotes(snip)`${4:TODO: Docstring for $1.}`!p",
            "write_function_docstring(t, snip) `",
                "\t${5:${VISUAL:pass}}"
        ],
    "description": "static method with docstrings"
    },
    "from import": {
        "prefix": ["from"],
        "body": [
"from ${1:module} import ${2:Stuff}"
        ],
    "description": "from module import name"
    },
    "roprop": {
        "prefix": ["roprop"],
        "body": [
"@property",
"def ${1:name}(self):",
	"\t${2:return self._$1}$0"
        ],
    "description": "read Only Property"
    },
    "read write property": {
        "prefix": ["rwprop"],
        "body": [
"def ${1:name}():",
	"\t`!p snip.rv = triple_quotes(snip) if t[2] else ''",
"`${2:TODO: Docstring for $1.}`!p",
"if t[2]:",
	"\tsnip >> 1",
"",
	"\tstyle = get_style(snip)",
	"\tsnip.rv += '\n' + snip.mkline('', indent='')",
	"\tsnip += format_return(style)",
	"\tsnip.rv += '\n' + snip.mkline('', indent='')",
	"\tsnip += triple_quotes(snip)",
"else:",
	"\tsnip.rv = \"\"`",
	"\tdef fget(self):",
		"\t\treturn self._$1$0",
"",
	"\tdef fset(self, value):",
		"\t\tself._$1 = value",
	"\treturn locals()",
"",
"$1 = property(**$1(), doc=$1.__doc__)"
        ],
    "description": "read write property"
    },
    "if": {
        "prefix": ["if"],
        "body": [
"if ${1:condition}:",
	"\t${2:${VISUAL:pass}}"
        ],
    "description": "if statement"
    },
    "if/else": {
        "prefix": ["ife"],
        "body": [
"if ${1:condition}:",
	"\t${2:${VISUAL:pass}}",
"else:",
	"\t${3:pass}"
        ],
    "description": "if / else statemtn"
    },
    "ifee": {
        "prefix": ["ifee"],
        "body": [
"if ${1:condition}:",
	"\t${2:${VISUAL:pass}}",
"elif ${3:condition}:",
	"\t${4:pass}",
"else:",
	"\t${5:pass}"
        ],
    "description": "if / elif / else statement"
    },
    "try": {
        "prefix": ["try"],
        "body": [
"try:",
	"\t${1:${VISUAL:pass}}",
"except ${2:Exception} as ${3:e}:",
	"\t${4:raise $3}",
"endsnippet"
        ],
    "description": "try / except statement"
    },
    "try except else": {
        "prefix": ["trye"],
        "body": [
"try:",
	"\t${1:${VISUAL:pass}}",
"except ${2:Exception} as ${3:e}:",
	"\t${4:raise $3}",
"else:",
	"\t${5:pass}",
"endsnippet"
        ],
    "description": "try / except / else statement"
    },
    "try except finally": {
        "prefix": ["tryf"],
        "body": [
"try:",
	"\t${1:${VISUAL:pass}}",
"except ${2:Exception} as ${3:e}:",
	"\t${4:raise $3}",
"finally:",
	"\t${5:pass}",
"endsnippet"
        ],
    "description": "try / except / finally statement"
    },
    "try except else finally": {
        "prefix": ["tryef"],
        "body": [
"try:",
	"\t${1:${VISUAL:pass}}",
"except${2: ${3:Exception} as ${4:e}}:",
	"\t${5:raise}",
"else:",
	"\t${6:pass}",
"finally:",
	"\t${7:pass}",
"endsnippet"
        ],
    "description": "try / except / else / finally statement"
    },
    "assert equal": {
        "prefix": ["ae"],
        "body": [
"self.assertEqual(${1:${VISUAL:first}}, ${2:second})"
        ],
    "description": "assert equal"
    },
    "assert true": {
        "prefix": ["at"],
        "body": [
"self.assertTrue(${1:${VISUAL:expression}})"
        ],
    "description": "assert true"
    },
    "assert false": {
        "prefix": ["af"],
        "body": [
"self.assertFalse(${1:${VISUAL:expression}})"
        ],
    "description": "assert false"
    },
    "assert almost equal": {
        "prefix": ["aae"],
        "body": [
"self.assertAlmostEqual(${1:${VISUAL:first}}, ${2:second})"
        ],
    "description": "assert almost equal"
    },
    "assert raises": {
        "prefix": ["ar"],
        "body": [
"self.assertRaises(${1:exception}, ${2:${VISUAL:func}}${3/.+/, /}${3:arguments})"
        ],
    "description": "assert raises"
    },
    "assert is none": {
        "prefix": ["an"],
        "body": [
"self.assertIsNone(${1:${VISUAL:expression}})"
        ],
    "description": "assert is none"
    },
    "assert is not none": {
        "prefix": ["ann"],
        "body": [
"self.assertIsNotNone(${1:${VISUAL:expression}})"
        ],
    "description": "assert is not none"
    },
    "pyunit testcase": {
        "prefix": ["testcase"],
        "body": [

"class Test${1:Class}(${2:unittest.TestCase}):",
"",
	"\t`!p snip.rv = triple_quotes(snip)`${3:Test case docstring.}`!p snip.rv = triple_quotes(snip)`",
"",
	"\tdef setUp(self):",
		"\t\t${4:pass}",
"",
	"\tdef tearDown(self):",
		"\t\t${5:pass}",
"",
	"\tdef test_${6:name}(self):",
		"\t\t${7:${VISUAL:pass}}"
        ],
    "description": "pyunit testcase"
    },
    "pocoo doc": {
        "prefix": ["pmdoc"],
        "body": [
"# -*- coding: utf-8 -*-",
"\"\"\"",
	"\t`!p snip.rv = get_dir_and_file_name(snip)`",
	"\t`!p snip.rv = '~' * len(get_dir_and_file_name(snip))`",
"",
	"\t${1:DESCRIPTION}",
"",
	"\t:copyright: (c) `date +%Y` by ${2:YOUR_NAME}.",
	"\t:license: ${3:LICENSE_NAME}, see LICENSE for more details.",
"\"\"\"",
"$0"
        ],
    "description": "pocoo style module doc string"
    }
}

